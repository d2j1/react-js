
Episode-04 | Talk is Cheap, Show Me the Code


Inline CSS - 

const ResCard = () => {
  return (
    <div style={{ backgroundColor: "lightblue", padding: "20px", borderRadius: "10px" }}>
      <h2 style={{ color: "darkblue" }}>Restaurant Name</h2>
      <p style={{ fontSize: "14px", color: "gray" }}>Cuisine: Italian</p>
    </div>
  );
};

export default ResCard;


Css style using const variable - 

const resCardStyle = {
  backgroundColor: "lightyellow",
  padding: "20px",
  border: "1px solid orange",
  borderRadius: "10px"
};

const titleStyle = {
  color: "darkgreen",
  fontSize: "20px"
};

const ResCard = () => {
  return (
    <div style={resCardStyle}>
      <h2 style={titleStyle}>Restaurant Name</h2>
      <p style={{ color: "brown" }}>Cuisine: Indian</p>
    </div>
  );
};

export default ResCard;


Props - 


1. Props with values

Passing explicit values:

const ResCard = (props) => {
  return (
    <div style={{ padding: "10px", border: "1px solid black" }}>
      <h2>{props.name}</h2>
      <p>Cuisine: {props.cuisine}</p>
    </div>
  );
};

// Usage
<ResCard name="Dominos" cuisine="Pizza" />
<ResCard name="KFC" cuisine="Chicken" />

2. Props without values (boolean shorthand)

If you pass a prop without a value, React sets it as true.

const ResCard = (props) => {
  return (
    <div>
      <h2>{props.name}</h2>
      <p>Featured: {props.featured ? "Yes" : "No"}</p>
    </div>
  );
};

// Usage
<ResCard name="Subway" featured />   // featured = true
<ResCard name="Burger King" />       // featured = undefined (falsey)

3. Props with default values (using defaultProps)
const ResCard = ({ name, cuisine = "Not specified" }) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>Cuisine: {cuisine}</p>
    </div>
  );
};

// Usage
<ResCard name="Starbucks" cuisine="Coffee" />
<ResCard name="Local Dhaba" />   // will use default cuisine = "Not specified"

4. Props with object styles (dynamic inline CSS)
const ResCard = ({ name, cuisine, highlight }) => {
  const cardStyle = {
    padding: "15px",
    border: "1px solid gray",
    backgroundColor: highlight ? "lightgreen" : "white"
  };

  return (
    <div style={cardStyle}>
      <h2>{name}</h2>
      <p>Cuisine: {cuisine}</p>
    </div>
  );
};

// Usage
<ResCard name="Biryani House" cuisine="Biryani" highlight />
<ResCard name="Dominos" cuisine="Pizza" />

5. Props with children

Special prop for passing JSX/content inside a component.

const ResCard = ({ name, children }) => {
  return (
    <div style={{ border: "1px solid black", padding: "10px" }}>
      <h2>{name}</h2>
      <div>{children}</div>
    </div>
  );
};

// Usage
<ResCard name="Food Court">
  <button>Order Now</button>
  <p>Open till 11 PM</p>
</ResCard>

const Greeting = (props) => {
  return <h1>Hello, {props.name}!</h1>;
};
ðŸ”¹ Passing Props
1. With values
jsx
Copy code
const Greeting = ({ name, age }) => {
  return (
    <h2>
      Hello {name}, you are {age} years old.
    </h2>
  );
};

// Usage
<Greeting name="John" age={25} />
ðŸ‘‰ Output: Hello John, you are 25 years old.

2. Without values (Boolean shorthand)
jsx
Copy code
const Button = ({ primary }) => {
  return (
    <button style={{ backgroundColor: primary ? "blue" : "gray", color: "white" }}>
      Click Me
    </button>
  );
};

// Usage
<Button primary />   // primary = true
<Button />           // primary = undefined (treated as false)
ðŸ‘‰ <Button primary /> makes the button blue.
ðŸ‘‰ <Button /> makes it gray.

3. With default values (using defaultProps)
jsx
Copy code
const Welcome = ({ name, country }) => {
  return (
    <h2>
      Welcome {name} from {country}!
    </h2>
  );
};

// Default props
Welcome.defaultProps = {
  name: "Guest",
  country: "Unknown"
};

// Usage
<Welcome />                      // â†’ Welcome Guest from Unknown!
<Welcome name="Alice" />          // â†’ Welcome Alice from Unknown!
<Welcome name="Bob" country="US" /> // â†’ Welcome Bob from US!
4. Default values (using ES6 destructuring)
jsx
Copy code
const Profile = ({ username = "Anonymous", age = 18 }) => {
  return (
    <p>
      {username}, {age} years old
    </p>
  );
};

// Usage
<Profile />                // â†’ Anonymous, 18 years old
<Profile username="Raj" /> // â†’ Raj, 18 years old
5. Props with functions
jsx
Copy code
const Counter = ({ onIncrement }) => {
  return <button onClick={onIncrement}>Increase</button>;
};

// Usage
<Counter onIncrement={() => alert("Incremented!")} />


Destructuring props on the fly -

Example 1: Simple destructuring on the fly
const Greeting = ({ name, age }) => {
  return (
    <h2>
      Hello {name}, you are {age} years old.
    </h2>
  );
};

// Usage
<Greeting name="John" age={25} />


ðŸ‘‰ No need to write props.name or props.age.

ðŸ”¹ Example 2: With default values while destructuring
const Profile = ({ username = "Anonymous", age = 18 }) => {
  return (
    <p>
      {username}, {age} years old
    </p>
  );
};

// Usage
<Profile />                // â†’ Anonymous, 18 years old
<Profile username="Alice" /> // â†’ Alice, 18 years old

ðŸ”¹ Example 3: Nested props destructuring
const UserCard = ({ user: { name, email } }) => {
  return (
    <div>
      <h3>{name}</h3>
      <p>{email}</p>
    </div>
  );
};

// Usage
<UserCard user={{ name: "Raj", email: "raj@example.com" }} />

ðŸ”¹ Example 4: Destructuring + children (on the fly)
const Card = ({ title, children }) => {
  return (
    <div style={{ border: "1px solid black", padding: "10px" }}>
      <h3>{title}</h3>
      <div>{children}</div>
    </div>
  );
};

// Usage
<Card title="Info Card">
  <p>This is inside the card.</p>
</Card>



Config driven UI - 


A Config Driven UI is a way of building user interfaces where the layout, components, styling, and even behavior of the UI are not hardcoded directly in the frontend code. Instead, they are defined using configuration files or metadata (often in JSON, YAML, or similar formats).

The frontend application reads the configuration at runtime (or build time), and then renders the UI dynamically based on that configuration.

So instead of writing:

<Button label="Submit" color="blue" size="large" />


You might have a configuration like:

{
  "component": "Button",
  "props": {
    "label": "Submit",
    "color": "blue",
    "size": "large"
  }
}


And your frontend engine interprets this JSON to render the button.

2. Why do we need Config Driven UI?

Config Driven UI is used when:

You want flexibility â€“ change the UI without redeploying the app.

You have different variations of the UI for different users, roles, or regions.

You want non-developers (like product managers or designers) to control the UI by just editing configs.

Youâ€™re building multi-tenant applications (e.g., SaaS), where different clients need custom UI layouts but you donâ€™t want to maintain separate codebases.

You need to scale UI development (fewer code changes, more controlled by metadata).

3. How does it work?

At a high level:

Configuration Layer
A config file (usually JSON/YAML) defines:

Which components to render

Order/layout

Styling

Actions (like navigation, API calls, validation rules, etc.)

Example config:

{
  "pageTitle": "User Registration",
  "components": [
    {
      "type": "Input",
      "props": { "label": "Name", "placeholder": "Enter your name" }
    },
    {
      "type": "Input",
      "props": { "label": "Email", "placeholder": "Enter your email" }
    },
    {
      "type": "Button",
      "props": { "label": "Register", "action": "submitForm" }
    }
  ]
}


UI Renderer / Engine
A frontend engine (React/Angular/Vue) reads the configuration and dynamically creates UI elements:

It sees "type": "Input" and maps it to your CustomInput component.

It applies props from config to the component.

It assembles them in the order given.

Behavior Binding
Actions like "submitForm" are mapped to business logic in your app.

So the code doesnâ€™t say "create an input" directly â€” it just interprets configs.

4. Benefits

Dynamic UI changes without code deployment.

Reusability â€“ same engine, different configs â†’ different UIs.

Multi-tenancy â€“ one app, many clients with custom looks.

Faster iteration â€“ update configs to test new flows quickly.

Decoupling â€“ separates business rules/UI layout from actual rendering logic.

5. Real-world Examples

Form builders (Google Forms, Typeform): The form layout is stored in config and rendered dynamically.

Survey platforms (SurveyMonkey): Each survey question is config-driven.

Low-code platforms (OutSystems, Retool, Mendix): Entire UIs generated from configs.

SaaS apps with custom dashboards (like Salesforce): UI differs per user but powered by same engine.

6. Trade-offs / Challenges

Complexity: You need to build a flexible rendering engine.

Performance: Parsing configs at runtime can be slower.

Debugging: Harder to trace issues since UI is not explicit code.

Limited control: Developers may feel constrained if everything must come from configs.

Testing: You test configs as well as code.

7. Small Example in React

Imagine a config-driven form:

Config (form.json)

{
  "title": "Login Form",
  "components": [
    {
      "type": "Input",
      "props": { "label": "Username", "placeholder": "Enter username" }
    },
    {
      "type": "Input",
      "props": { "label": "Password", "placeholder": "Enter password", "type": "password" }
    },
    {
      "type": "Button",
      "props": { "label": "Login", "action": "loginUser" }
    }
  ]
}


Renderer (React Pseudo-code)

const componentMap = {
  Input: CustomInput,
  Button: CustomButton
};

const Renderer = ({ config }) => (
  <div>
    <h2>{config.title}</h2>
    {config.components.map((c, i) => {
      const Component = componentMap[c.type];
      return <Component key={i} {...c.props} />;
    })}
  </div>
);


Now changing the form means just editing form.json â€“ no code change!


Example 2 - 


The Configuration (JSON)
{
  "title": "Sales Dashboard",
  "layout": "grid",
  "widgets": [
    {
      "type": "KPI",
      "props": { "label": "Total Revenue", "value": "$120K" }
    },
    {
      "type": "Chart",
      "props": { 
        "chartType": "bar", 
        "title": "Monthly Sales", 
        "dataSource": "api/sales/monthly" 
      }
    },
    {
      "type": "Table",
      "props": { 
        "title": "Top Products", 
        "dataSource": "api/sales/products" 
      }
    }
  ]
}

2. The Renderer (React-like Pseudo-code)
const widgetMap = {
  KPI: KPIWidget,
  Chart: ChartWidget,
  Table: TableWidget
};

const DashboardRenderer = ({ config }) => (
  <div>
    <h1>{config.title}</h1>
    <div className="grid-layout">
      {config.widgets.map((w, i) => {
        const Widget = widgetMap[w.type];
        return <Widget key={i} {...w.props} />;
      })}
    </div>
  </div>
);

3. What Happens

The app reads the config.

Sees "KPI", renders a KPI card.

Sees "Chart", renders a bar chart using API data.

Sees "Table", renders a data table of products.

If a new client wants a Pie Chart instead of Bar Chart, just update config:

"type": "Chart",
"props": { "chartType": "pie", "title": "Monthly Sales", "dataSource": "api/sales/monthly" }


â†’ No code change, no redeploy.

4. Why this is useful

Different clients (or roles like admin vs user) can see different dashboards.

Product managers can configure dashboards without bothering developers.

You scale to 100s of clients with one codebase, just changing configs.


Mapping the data - 


import React from "react";

// Arrow function component
const UserList = ({ users = [] }) => {
  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-2">User List</h2>
      <ul className="list-disc pl-5">
        {users.map((user, index) => (
          <li key={index} className="mb-1">
            {user.name} â€” {user.email}
          </li>
        ))}
      </ul>
    </div>
  );
};

// Example usage with props
const App = () => {
  const users = [
    { name: "Aarav", email: "aarav@example.com" },
    { name: "Priya", email: "priya@example.com" },
    { name: "Vikram", email: "vikram@example.com" }
  ];

  return <UserList users={users} />;
};

export default App;

Why each rendered component needs unique key in react ?

1. Reactâ€™s Rendering Process (Virtual DOM)

React uses a Virtual DOM to decide what actually needs to change in the browser DOM.

When your component re-renders:

React builds a new virtual DOM tree.

It compares it with the previous virtual DOM tree (this process is called reconciliation).

Then React updates only what changed (instead of re-rendering everything).

2. Where key Fits In

When React renders a list using .map(), it needs a way to track each item between renders.

The key helps React:

Know which items are the same as before.

Know which items were added, removed, or reordered.

Without a unique key:

React may get confused and unnecessarily re-render items, even if they didnâ€™t change.

3. Example Without Key
const users = ["Aarav", "Priya", "Vikram"];

<ul>
  {users.map((user) => (
    <li>{user}</li>
  ))}
</ul>


React will show a warning:

Warning: Each child in a list should have a unique "key" prop.

4. Example With Key
<ul>
  {users.map((user, index) => (
    <li key={index}>{user}</li>
  ))}
</ul>


Now React can correctly track each <li>.

5. Why Unique Key Matters (Reordering Case)

Imagine you use index as key, and the list changes:

// Initial
["Aarav", "Priya", "Vikram"]

// After update
["Priya", "Aarav", "Vikram"]


If index was the key:

Aarav (index 0) â†’ now at position 1

Priya (index 1) â†’ now at position 0
React sees keys [0,1,2] unchanged and assumes content didnâ€™t move, so it just swaps text but may reuse DOM nodes incorrectly.

This can cause:

Wrong input values sticking in forms.

Wrong animations.

Subtle UI bugs.

âœ… Using a unique, stable key (like user.id) ensures React knows the item actually moved.

6. Summary

key tells React which element is which across renders.

It makes reconciliation efficient (only re-render what really changed).

Always use a unique and stable identifier (like id from database).

Avoid using index as key unless the list is static and never reordered.


Index as a key is an anti-pattern ->

using index as a key is an anti-pattern, use something unique like UUID. 

1. Reminder: What key does

React uses the key prop to:

Identify elements in a list between renders.

Decide whether to reuse, reorder, or recreate DOM elements.
ðŸ‘‰ The key must be unique and stable across renders.

2. Why index as key Is an Antipattern

Using the array index as a key (key={index}) is problematic when:

List items can change order

Items can be added or removed

Items have state (like input fields, animations, or selections)

Because index is not stable:
If items move, their index changes â†’ React reuses DOM nodes incorrectly â†’ bugs.

3. Example of the Bug

Suppose we have a list of inputs:

const [users, setUsers] = React.useState(["Aarav", "Priya", "Vikram"]);

return (
  <ul>
    {users.map((user, index) => (
      <li key={index}>
        <input defaultValue={user} />
      </li>
    ))}
  </ul>
);


Now, if we reorder the array:

setUsers(["Priya", "Aarav", "Vikram"]);


What happens?

React sees keys: 0, 1, 2 â†’ unchanged.

It thinks: "same elements, no need to recreate".

So instead of moving inputs, it just swaps text nodes.
ðŸ‘‰ Result: The input you typed into may now appear under the wrong user!

âš¡ User sees their input â€œjumpâ€ to another field â†’ confusing bug.

4. Why This Happens

Index depends on order.

If order changes, the same index may point to a different item than before.

React reuses the DOM node incorrectly â†’ stale values, broken animations, weird reordering.

5. When index is Acceptable

Using index as key is fine only if:

The list is static (no reordering, no additions/removals).
Example: rendering 5 stars in a rating widget.

{[...Array(5)].map((_, i) => <Star key={i} />)}


Items are purely visual and have no state.

6. Best Practice

Always use a unique, stable identifier from your data (like user.id, product.sku, post.slug).

Example:

{users.map(user => (
  <li key={user.id}>{user.name}</li>
))}


