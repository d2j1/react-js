
Recommended folder structure - 

src/
│── assets/              # Images, icons, fonts, and global styles
│   ├── images/
│   ├── icons/
│   └── styles/
│
│── components/          # Reusable UI components
│   ├── common/          # Very generic (Button, Input, Modal, Loader, etc.)
│   ├── layout/          # Navbar, Sidebar, Footer, LayoutWrapper, etc.
│   └── widgets/         # More specific reusable parts (Card, Chart, TableRow)
│
│── features/            # Group by features or modules
│   ├── auth/            # Authentication (LoginForm, RegisterForm)
│   ├── profile/         # User profile
│   ├── dashboard/       # Dashboard-related screens/components
│   └── settings/        # Settings pages
│
│── hooks/               # Custom hooks (useFetch, useLocalStorage, useDebounce)
│
│── context/             # React Contexts (AuthContext, ThemeContext)
│
│── pages/               # Page-level components used in routing
│   ├── Home/
│   ├── About/
│   ├── Contact/
│   ├── Login/
│   └── NotFound/
│
│── services/            # API calls and external service integrations
│   ├── apiClient.js     # Axios/fetch setup
│   └── userService.js   # Example API wrapper
│
│── utils/               # Utility/helper functions (validators, formatters, constants)
│
│── routes/              # Routing configuration and ProtectedRoute
│   └── AppRoutes.jsx
│
│── App.jsx              # Root app component
│── main.jsx             # Entry point (ReactDOM.createRoot)
│── index.css            # Global CSS (minimal if using Tailwind/SCSS)
│
└── tests/               # Unit/integration tests
    ├── __mocks__/
    └── components/


Never keep the hardcoded data and constants  in the component file.

Create utils folder inside src folder and then inside this folder create different files to store all the constants or hardcoded data. Export this hardcoded data from these constant files and import it whereever necessary. 


Different types of exports - 


1) default exports - 

// Button.jsx
const Button = ({ label }) => <button>{label}</button>;

export default Button;

importing above - 

import Button from "./Button";



2) Named export - 

// components.js
export const Button = ({ label }) => <button>{label}</button>;

export const Input = ({ value, onChange }) => <input value={value} onChange={onChange} />;

importing above - 

import { Button, Input } from "./components";


Hooks - Hooks are special functions in React that let you “hook into” React features (like state, lifecycle, or context) without writing class components.

Rules of Hooks

Only call hooks at the top level of a function component (not inside loops, conditions, or nested functions).

Only call hooks from:

React function components

Custom hooks (your own hook functions)

These rules keep React’s internal state tracking predictable.



useState hook - 

What is useState?

useState is a React hook that lets you add state to functional components.

State is data that changes over time and determines how the component looks or behaves.

Without useState, functional components would only render static UI.

Syntax
const [state, setState] = useState(initialValue);


state → current value (like a variable).

setState → function to update the state.

initialValue → the starting value of the state.

👉 Every time you call setState, React re-renders the component with the new state.

Example 1: Counter
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // initial value is 0

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;


Starts at 0.

Each click calls setCount, React re-renders with updated value.

Example 2: Toggle Button
function Toggle() {
  const [isOn, setIsOn] = useState(false);

  return (
    <button onClick={() => setIsOn(!isOn)}>
      {isOn ? "ON" : "OFF"}
    </button>
  );
}


Here state is a boolean, toggled on each click.

Example 3: Storing Objects

useState can hold objects or arrays, not just numbers/booleans.

function UserProfile() {
  const [user, setUser] = useState({
    name: "Alice",
    age: 25,
  });

  return (
    <div>
      <p>{user.name} ({user.age})</p>
      <button onClick={() => setUser({ ...user, age: user.age + 1 })}>
        Birthday 🎉
      </button>
    </div>
  );
}


👉 Important: You must spread (...user) the old object, otherwise you’ll overwrite the whole object.

Example 4: Initial State from a Function

If computing the initial state is expensive, you can pass a function to useState.
React will call it only once (on first render).

function ExpensiveComponent() {
  const [value, setValue] = useState(() => {
    console.log("Expensive calculation running...");
    return 42;
  });

  return <p>Value: {value}</p>;
}


1. Updating State Based on Previous Value

⚠️ Common mistake:

setCount(count + 1);


This works, but in async updates (like multiple state updates in one render), it can fail.

✅ Correct (functional update form):

setCount(prevCount => prevCount + 1);


Example:

function Counter() {
  const [count, setCount] = useState(0);

  const incrementTwice = () => {
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
  };

  return (
    <>
      <p>{count}</p>
      <button onClick={incrementTwice}>+2</button>
    </>
  );
}


👉 Without functional updates, it would only add +1 instead of +2.

2. Multiple State Variables vs One Object

You can keep related values in separate states or a single object.

✅ Separate states (cleaner in most cases):

const [firstName, setFirstName] = useState("Alice");
const [lastName, setLastName] = useState("Smith");


✅ Object state (good if values are tightly coupled):

const [user, setUser] = useState({ firstName: "Alice", lastName: "Smith" });

setUser(prev => ({ ...prev, lastName: "Johnson" }));


👉 Best practice: Use separate states unless values must always update together.

3. Lazy Initialization (performance tip)

For expensive initial values, use a function:

const [list, setList] = useState(() => {
  return JSON.parse(localStorage.getItem("myList")) || [];
});


👉 React calls this initializer only once.

4. State and Forms

Forms are where you use useState a lot.

function SignupForm() {
  const [form, setForm] = useState({ email: "", password: "" });

  const handleChange = e => {
    const { name, value } = e.target;
    setForm(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = e => {
    e.preventDefault();
    console.log("Submitting", form);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="email" value={form.email} onChange={handleChange} />
      <input name="password" type="password" value={form.password} onChange={handleChange} />
      <button type="submit">Sign Up</button>
    </form>
  );
}


👉 Using an object is handy when managing multiple fields.

5. State vs Derived Values

Not everything should be stored in state.

❌ Don’t store values you can compute from other state/props.

✅ Store only the minimal state needed.

Bad example:

const [firstName, setFirstName] = useState("Alice");
const [lastName, setLastName] = useState("Smith");
const [fullName, setFullName] = useState(firstName + " " + lastName); // ❌ redundant


Better:

const fullName = `${firstName} ${lastName}`; // derived

6. Avoiding Unnecessary Renders

Each setState triggers a re-render. If your component re-renders too much:

Use useMemo or useCallback for derived data/functions.

Keep local UI-only state with useState, and move global/shared state into Context or state libraries (Redux, Zustand, etc.) when scaling.

7. Common Pitfalls

Overwriting state objects/arrays instead of merging them.

setUser({ age: 30 }); // ❌ wipes out name, email, etc.
setUser(prev => ({ ...prev, age: 30 })); // ✅


Using state for things that don’t belong in state (e.g., refs, constants).


Virtual DOM - 

What is the DOM?

DOM = Document Object Model

It’s a tree-like structure of your webpage where every element (div, button, p, etc.) is a node.

Browsers use the DOM to render and update the UI.

👉 Problem: The real DOM is slow to update.

Every time you change it, the browser recalculates styles, layouts, and re-renders.

If you update it frequently (like in an app with animations or lists), performance suffers.

🔹 What is the Virtual DOM?

The Virtual DOM is a lightweight JavaScript copy of the real DOM that React keeps in memory.

When your state or props change, React doesn’t immediately touch the real DOM.

Instead, it:

Updates the Virtual DOM (cheap, since it’s just JS objects).

Runs a diffing algorithm (reconciliation) to figure out what actually changed.

Updates only the necessary parts of the real DOM.

👉 This process makes updates much faster and more efficient.

🔹 How it Works (Step by Step)

Initial Render
React builds a Virtual DOM tree from your components and renders it into the real DOM.

State/Props Change
A new Virtual DOM tree is created (React re-runs your component function).

Diffing
React compares the new Virtual DOM with the old one (using Fiber).

Minimal DOM Updates
React applies only the differences to the real DOM.

🔹 Example
function App() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <h1>Hello</h1>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}


Initial render → React builds VDOM with <h1>Hello</h1> <p>Count: 0</p> <button>Increment</button>.

After clicking → new VDOM has <p>Count: 1</p>.

React compares old and new VDOM → sees only <p> changed.

React updates just the <p> in the real DOM, not the <h1> or <button>.


Reconciliation algorithm or react fiber - 

What is Reconciliation in React?

React uses a Virtual DOM. Whenever your component’s state/props change, React re-renders the component virtually first (not directly on the browser DOM, which is slow).

But React now has two trees:

The old tree (current UI in the DOM).

The new tree (what UI should look like after update).

👉 Reconciliation is the process of comparing these two trees and figuring out:

What has changed?

What needs to be updated in the real DOM?

This makes React fast because instead of re-rendering everything, it only updates the parts that changed.

🔹 Why React Fiber?

Before React 16 (2017), React used a stack-based algorithm for reconciliation. Problems with that:

Rendering was synchronous — once React started updating, it wouldn’t stop until it finished.

If the component tree was huge, the browser would “freeze” and the UI became janky.

👉 Solution: React Fiber — a complete rewrite of React’s core.
Fiber introduced incremental rendering:

React can pause work, split it into chunks, and resume later.

Higher priority updates (like typing, animations) can interrupt lower priority ones (like rendering a big list).

🔹 What is a Fiber?

A Fiber is a JavaScript object that represents a unit of work (a node in the React tree).

Each fiber stores:

The component type (function/class/host element).

Its props and state.

Its return (parent), child, and sibling links → making a tree structure.

Effect tags → what needs to change in the DOM (add, update, delete).

👉 Think of Fiber as React’s way to track work in progress and decide what to do with it.

🔹 The Fiber Reconciliation Algorithm (Step by Step)

Reconciliation under Fiber happens in two phases:

1. Render Phase (Reconciliation Phase)

React builds a work-in-progress tree (new virtual tree).

It compares the new elements with the old fibers (diffing).

Marks changes (effects) → e.g., "update text", "remove node".

This phase is interruptible (can pause for high-priority tasks).

2. Commit Phase

React applies the effects to the real DOM.

This phase is synchronous and cannot be interrupted.

It runs very fast because it only updates changed nodes.

🔹 How React Decides What Changed? (Diffing Rules)

React uses heuristics (rules) to make reconciliation efficient:

Different element types → replace node completely

<div /> → <span />  // React destroys old div, creates new span


Same type element → update props & children

<button class="red" /> → <button class="blue" />  
// React updates class from red → blue


Lists need keys
Keys help React match elements across renders.

// BAD (React may recreate items unnecessarily)
items.map((item, index) => <li key={index}>{item}</li>);

// GOOD (React reuses DOM nodes properly)
items.map(item => <li key={item.id}>{item.name}</li>);


👉 This is why using index as a key is an anti-pattern — it confuses reconciliation when list order changes.

🔹 Fiber Benefits in Production

Prioritization: User interactions (typing, animations) feel smooth even with heavy UI.

Better scheduling: React can pause/restart rendering work.

Granular updates: Only the necessary DOM nodes update.

Concurrent Mode (React 18): Fiber is what makes concurrent rendering possible.

🔹 Real-World Example

Imagine rendering a big list of 10,000 items:

Old React (pre-Fiber): would freeze UI until list finished rendering.

Fiber: can render items in chunks, show partial UI, and let you still scroll/type smoothly.

Diff algorithm - 

The Problem

When your component re-renders, React builds a new Virtual DOM tree.
But React needs to figure out:

👉 What changed between the old tree and the new tree?

Naively comparing two trees node by node has a time complexity of O(n³) (very expensive for large UIs).

React needed a faster diffing algorithm.

🔹 React’s Diffing Algorithm (Heuristics)

React uses two main assumptions (heuristics) to make the algorithm much faster (approx. O(n)):

Different element types → destroy and rebuild

If an element’s type changes, React tears down the old subtree and builds a new one.

<div>Hello</div>   →   <span>Hello</span>


React removes the <div> and creates a new <span>.

Elements of the same type → compare props & children

If types are the same, React looks at the attributes (props) and children.

<button class="blue">Click</button>  
→  
<button class="red">Click</button>


React only updates the class, not the whole button.

🔹 Child Diffing (Keys Matter!)

When dealing with lists, React needs to match old and new children.

Without Keys
<ul>
  <li>A</li>
  <li>B</li>
</ul>

→

<ul>
  <li>B</li>
  <li>A</li>
</ul>


React may delete both <li>s and recreate them → inefficient.

With Keys
<ul>
  <li key="A">A</li>
  <li key="B">B</li>
</ul>

→

<ul>
  <li key="B">B</li>
  <li key="A">A</li>
</ul>


React sees keys "A" and "B" are the same, so it just swaps their positions without recreating nodes.

👉 That’s why unique keys are critical in lists.

🔹 Example
function App() {
  const [items, setItems] = React.useState(["A", "B", "C"]);

  return (
    <ul>
      {items.map((item) => (
        <li key={item}>{item}</li>
      ))}
      <button onClick={() => setItems(["C", "B", "A"])}>Reverse</button>
    </ul>
  );
}


With keys, React reuses <li> nodes and just reorders them.

Without keys, React may destroy and rebuild all <li>s.

🔹 Performance Summary

Same type elements → update in place.

Different type elements → destroy & rebuild.

Lists → use keys to minimize DOM operations.

Complexity: O(n) instead of O(n³).

✅ In short:
React’s diffing algorithm (reconciliation) works by applying rules:

Compare types → same type = update, different type = replace.

For children, use keys to track identity and reorder efficiently.

This lets React update only what’s necessary in the real DOM.


Incremental rendering - 

The Problem with Old React (pre-Fiber)

In old React (before React 16), when a component updated, React would:

Re-render the component.

Diff the old Virtual DOM and the new Virtual DOM.

Apply all changes to the real DOM in one big chunk.

👉 This meant React was synchronous — once it started rendering, it couldn’t stop until it finished.

If the component tree was huge, the main thread got blocked.

That caused UI freezes, dropped frames, and poor performance on slower devices.

🔹 Incremental Rendering (React Fiber Solution)

With Fiber, React introduced incremental rendering.
Instead of rendering everything in one go, React can:

✅ Break rendering work into small chunks (units of work).
✅ Pause work if something more important (like user input, animations) needs to happen.
✅ Resume work later without starting over.
✅ Abort work if it’s no longer needed (e.g., the user navigates away).

👉 This makes the UI stay responsive, even during heavy rendering.

🔹 How it Works

React Fiber treats rendering like a task scheduler:

Split work into fibers (nodes)
Each component (or part of the tree) becomes a "fiber" unit.

Prioritize work

High-priority tasks: user input, animations.

Low-priority tasks: background data fetching, off-screen updates.

Work loop

React processes fibers one by one.

After each fiber, React checks:

“Do I have time left in this frame?”

If not → pause.

Then resume later.

🔹 Example in Real Apps

Imagine you have a long list of items (say 10,000 rows).

Old React (sync):

Would try to render all 10,000 at once → UI freezes.

React Fiber (incremental):

Breaks rendering into chunks (maybe 50–100 items per frame).

User can still scroll or type while React works in the background.

Updates are applied gradually → smooth experience.

🔹 Benefits

UI remains responsive during rendering.

Handles large updates gracefully.

Enables features like Suspense, Concurrent Mode, and Streaming Server Rendering.

🔹 In Simple Words

Think of old React as trying to eat a whole pizza in one bite 🍕😵, blocking everything until it’s done.

Incremental rendering is like taking small bites, pausing to drink water, and letting others talk before continuing — much smoother 🍕🙂.

✅ Summary

Incremental rendering = breaking rendering work into chunks.

Introduced by React Fiber (React 16+).

Makes UI responsive by allowing React to pause/resume/abort rendering.

Used in concurrent features like Suspense and streaming rendering.



Array destructuring in java script - 

const colors = ["red", "green", "blue"];
const [first, second, third] = colors;

console.log(first);  // "red"
console.log(second); // "green"
console.log(third);  // "blue"


useState without destructuring - 

const stateArray = useState(0);
const count = stateArray[0];
const setCount = stateArray[1];


useState with destructuring - 

const [count, setCount] = useState(0);

