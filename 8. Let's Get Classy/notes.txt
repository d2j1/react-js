
In class based components the states are
created in constructor.


when class based components are called then first constructor is called and then render is called.

when class based components are called then first constructor of the parent class is called and then render of parent class is called and now child constructor is called and then child render is called.




below method is called when component is mounted - 

componentDidMount(){

}

ComponentDidMount is same as useEffect, we can use this for calling apis and other side effects.

below is the order of function calls in class component - 
1) Constructor 
2) Render
3) Component did mount

and below is the order of function call in class component of parent and child - 

1) parent Constructor 
2) parent Render
3) child constructor
4) child render 
5) child Component did mount
6) parent Component did mount



Parent Component with two child components - 

We‚Äôre dealing with React class components, and the lifecycle methods constructor, render, and componentDidMount.
You have a Parent component that renders two Child components.

General Rules

constructor()

Called first when the component is being created.

Initializes state, binds methods.

Never cause side effects (like fetching data).

render()

Called right after constructor.

Should be a pure function of props and state.

Returns JSX.

componentDidMount()

Called once after the component has been inserted into the DOM.

Good for network requests, subscriptions, timers, etc.

Execution Order (Parent ‚Üí Child)

When the Parent is mounted (first time):

Parent constructor()

Parent render()

Inside render, React sees two children ‚Üí starts mounting them.

Child1 constructor()

Child1 render()

Child2 constructor()

Child2 render()

Now React has built the virtual DOM tree of Parent + both Children.

It commits this to the actual DOM.

Child1 componentDidMount()

Child2 componentDidMount()

Parent componentDidMount()

Why this order?

React must fully render Parent and its Children before calling componentDidMount.

Children finish mounting before the Parent is considered ‚Äúdone‚Äù, so their componentDidMount runs first.

This ensures the Parent can safely interact with Child DOM nodes if needed in its own componentDidMount.

‚úÖ Final Order (mounting phase):

Parent constructor
Parent render
Child1 constructor
Child1 render
Child2 constructor
Child2 render
Child1 componentDidMount
Child2 componentDidMount
Parent componentDidMount


React component lifecycle - 


React Component Lifecycle (Class Components)

Think of a React component‚Äôs life in three main phases:

Mounting ‚Üí when the component is being created and added to the DOM.

Updating ‚Üí when the component re-renders because of changes.

Unmounting ‚Üí when the component is removed from the DOM.

Each phase has lifecycle methods that React calls in a specific order.

1. Mounting Phase

This happens when the component is first created and inserted into the DOM.

Order:

constructor(props)

Called before anything else.

Good place to initialize state and bind methods.

Avoid side effects (like API calls) here.

static getDerivedStateFromProps(props, state) (rarely used)

Lets you update state based on props before rendering.

Runs before every render, not just mounting.

render()

The only required method.

Returns JSX to describe what the UI looks like.

Should be pure (no state changes or API calls here).

componentDidMount()

Called once the component is fully mounted in the DOM.

Perfect place for: API calls, setting up subscriptions, timers, DOM manipulation.

2. Updating Phase

This happens whenever a component re-renders due to changes in props or state.

Order:

static getDerivedStateFromProps(props, state)

Same as before (rarely needed).

Runs before each render.

shouldComponentUpdate(nextProps, nextState)

Lets you control performance optimization.

Return true (default) to re-render, or false to block render.

render()

Called again to re-generate the JSX.

getSnapshotBeforeUpdate(prevProps, prevState) (rarely used)

Lets you capture information from the DOM before changes happen.

Example: scroll position.

componentDidUpdate(prevProps, prevState, snapshot)

Called after the DOM is updated.

Useful for reacting to prop/state changes, triggering network requests based on changes.

‚ö†Ô∏è Make sure to wrap side effects in conditions to avoid infinite loops.

3. Unmounting Phase

This happens when the component is removed from the DOM.

Order:

componentWillUnmount()

Cleanup goes here ‚Üí cancel API calls, remove event listeners, clear timers.

Very important for avoiding memory leaks.

4. Error Handling Phase

React also has lifecycle methods for handling errors in components.

static getDerivedStateFromError(error)

componentDidCatch(error, info)

These are used inside Error Boundaries to catch errors in child components.

‚úÖ Simplified Flow
Mounting
constructor ‚Üí render ‚Üí componentDidMount

Updating
getDerivedStateFromProps ‚Üí shouldComponentUpdate ‚Üí render ‚Üí getSnapshotBeforeUpdate ‚Üí componentDidUpdate

Unmounting
componentWillUnmount

üß† Key Points to Remember

constructor ‚Üí setup state.

render ‚Üí return JSX (pure).

componentDidMount ‚Üí API calls, subscriptions.

shouldComponentUpdate ‚Üí optimization.

componentDidUpdate ‚Üí run code after update.

componentWillUnmount ‚Üí cleanup.


componentDidUpdate and componentWillUnmount - 

When a class component mounts (appears on the screen) and then updates (re-renders because of setState or new props), the lifecycle methods fire in this sequence:

1. Mounting phase (when component is first created and inserted into the DOM)

Order:

constructor(props)

Initializes state.

Can bind methods if needed.

Runs only once when the component is created.

render()

Returns JSX to describe what UI should look like.

Pure function ‚Üí should not have side effects (like data fetching).

componentDidMount()

Runs once after initial render.

Safe place for:

API calls

Subscriptions

Setting up timers

If you call setState here, React will re-render again, but this happens after the initial render.

2. Updating phase (when props or state change)

Whenever you call this.setState() or a parent passes new props, React schedules an update.
Order:

render()

Runs again to update the UI with new state/props.

componentDidUpdate(prevProps, prevState)

Runs after the re-render and after the updated DOM is painted.

You can compare prevProps and prevState with current ones.

Often used for:

Reacting to prop/state changes (e.g., re-fetching data if an ID changed).

Running code after DOM updates.

‚ö†Ô∏è If you call setState inside componentDidUpdate without a condition, it will cause an infinite loop:

componentDidUpdate() {
   this.setState({count: this.state.count + 1}); // ‚ùå infinite loop
}


So, always guard with a condition:

componentDidUpdate(prevProps, prevState) {
   if (prevState.count !== this.state.count) {
      console.log("Count changed, safe to update something");
   }
}

3. Unmounting phase (when component is removed from DOM)

componentWillUnmount()

Cleanup work:

Clear timers

Remove event listeners

Cancel network requests

Runs only once, right before component is destroyed.

üîπ Where componentDidUpdate Fits

Imagine this flow in your UserClass example:

constructor ‚Üí initializes state with dummy data.

render ‚Üí renders with "Dummy Name / Default Location".

componentDidMount ‚Üí fetch starts, and then setState updates userInfo.

render (again) ‚Üí now React re-renders with fetched API data.

componentDidUpdate ‚Üí runs right after the DOM has updated with API data.

If you press your Set Count button:

setState is called ‚Üí schedules re-render.

render runs with new count.

componentDidUpdate runs ‚Üí logs "Component Did Update".

üîπ Visual Flow Diagram (Textual)
Mounting:
constructor ‚Üí render ‚Üí componentDidMount

Updating (on state/prop change):
render ‚Üí componentDidUpdate

Unmounting:
componentWillUnmount

üîπ Key Points about componentDidUpdate

Runs every time the component updates, unless prevented by shouldComponentUpdate (rarely used nowadays).

Good for running side effects that depend on changes.

Receives prevProps and prevState as arguments.

Runs after the DOM has already updated ‚Üí you can safely manipulate the DOM or read updated values.

üëâ So in your example:

First render shows dummy data.

After API fetch, setState updates ‚Üí triggers re-render.

Right after re-render, componentDidUpdate runs ‚Üí logs "Component Did Update".


